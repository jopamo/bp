# bison quick reference
## what you have

* `bison` is the real tool
* `/usr/bin/yacc` is a bison-provided wrapper for POSIX yacc mode
* installed data lives under `/usr/share/bison` with skeletons and XSLT helpers
* print dirs: `bison --print-datadir`, `bison --print-localedir`

---

# most useful CLI flags

## output control

* `-o OUT` set output file
* `-H, --header[=FILE]` also generate a header
* `-d` same as `-H` but name is derived automatically
* `-b PREFIX` set file prefix for outputs

## language and skeleton

* `-L c|c++|java|d` choose language
* `-S FILE` pick a specific skeleton from `/usr/share/bison/skeletons`

  * common C++ skeletons: `lalr1.cc`, `glr.cc`
  * plain C: `yacc.c`, `glr.c`

## diagnostics and reports

* `-W CATEGORY` enable warning categories like `yacc,deprecated,precedence,empty-rule`
* `--warnings=error` make warnings fatal
* `-f caret,fixit` enable caret diagnostics and machine-readable fixes
* `-v` or `--report=state` emit `.output` automaton report
* `--report=all` include states,itemsets,lookaheads,solved,cex
* `--color=auto` colored diagnostics

## parser tuning

* `-t` instrument parser for tracing (`%define parse.trace`)
* `--locations` enable location tracking (`%locations` in grammar is preferred)
* `-y` POSIX yacc emulation if you really need it

## viz

* `-g[=FILE]` Graphviz `.dot` automaton
* `--html[=FILE]`, `--xml[=FILE]` HTML or XML reports
* transform dot: `dot -Tpng parser.dot -o parser.png`

---

# modern grammar directives you’ll actually use

put these inside your `.y`

```yacc
%language "c++"                             // generate a C++ parser
%define api.namespace {parser}              // put classes in a namespace
%define api.value.type variant              // use std::variant for semantic values
%define parse.error verbose                 // nicer error messages
%define parse.trace                         // enable YYDEBUG-driven tracing
%define api.pure full                       // reentrant parser
%locations                                  // enable yylloc with line/column
%glr-parser                                 // use GLR if you have ambiguity
/* or choose stronger LR tables
%define lr.type ielr                        // IELR(1) tables
*/
%expect 0                                   // assert expected SR conflicts count
%expect-rr 0                                // assert expected RR conflicts count
```

C flavor tips

```yacc
%define api.value.type {union}              // or use %union{...}
%code requires {                            // goes into the header
  typedef struct { int line, column; } pos_t;
}
```

pass user data to reentrant parser

```yacc
%param { void* scanner }                    // example extra parameter
```

---

# minimal C++ demo you can build immediately

`demo.y`

```yacc
%language "c++"
%define api.namespace {demo}
%define api.value.type variant
%define parse.error verbose
%define api.pure full
%locations

%token <int> NUM
%type  <int> expr

%%

input:
    /* empty */
  | input expr '\n'        { std::cout << $2 << "\n"; }
  ;

expr:
    NUM                    { $$ = $1; }
  | expr '+' expr          { $$ = $1 + $3; }
  | '(' expr ')'           { $$ = $2; }
  ;

%%

%code provides {
// scanner interface stub
int yylex(demo::parser::semantic_type* yylval,
          demo::parser::location_type* yylloc);
void yyerror(const demo::parser::location_type& loc, const std::string& msg);
}

%code {
#include <iostream>
#include <string>

int yylex(demo::parser::semantic_type* yylval,
          demo::parser::location_type* yylloc) {
  int c = std::cin.peek();
  while (c == ' ' || c == '\t' || c == '\r') { std::cin.get(); c = std::cin.peek(); } // skip spaces
  if (std::isdigit(c)) { int v; std::cin >> v; yylval->emplace<int>(v); return NUM; }
  if (c == '\n' || c == '+' || c == '(' || c == ')') return std::cin.get();
  if (c == EOF) return 0;
  std::cin.get(); return c;
}

void yyerror(const demo::parser::location_type& loc, const std::string& msg) {
  std::cerr << "parse error at " << loc << ": " << msg << "\n";
}
}
```

build and run

```bash
bison -L c++ -o demo_parser.cc -H demo_parser.hh demo.y
c++ -std=c++20 -Wall -Wextra demo_parser.cc -o demo

# try it
printf '1+(2+3)\n' | ./demo
```

---

# typical C pipeline with Flex

`lexer.l`

```lex
%option noyywrap nodefault
%option yylineno

%{
#include "parser.h"         // generated by bison -H
#include <ctype.h>
%}

%%

[0-9]+      { yylval->ival = atoi(yytext); return NUM; }
"+"         { return '+'; }
"("         { return '('; }
")"         { return ')'; }
[ \t\r]+    { /* skip */ }
\n          { return '\n'; }
.           { return yytext[0]; }

%%
```

`parser.y`

```yacc
%define api.value.type {union}
%union { int ival; }
%token <ival> NUM
%type  <ival> expr
%define parse.error verbose

%%

input:
    /* empty */
  | input expr '\n'        { printf("%d\n", $2); }
  ;

expr:
    NUM                    { $$ = $1; }
  | expr '+' expr          { $$ = $1 + $3; }
  | '(' expr ')'           { $$ = $2; }
  ;

%%
```

build

```bash
bison -d -o parser.c parser.y
flex -o lexer.c lexer.l
cc -std=c11 -Wall -Wextra parser.c lexer.c -lfl -o calc
```

---

# automaton and conflict debugging

* generate state report: `bison -v parser.y` then inspect `parser.output`
* draw automaton graph: `bison -g parser.y && dot -Tsvg parser.dot -o parser.svg`
* turn on tracing at runtime: define `YYDEBUG=1` before including the generated parser and call `yydebug = 1;`
* silence known conflicts safely: add `%expect N` and `%expect-rr M` in your grammar

---

# file naming patterns you’ll see

* C default: `y.tab.c` and `y.tab.h` if no `-o`/`-H`
* with prefix: `-b foo` → `foo.tab.c`, `foo.tab.h`, `foo.output`
* with explicit names: `-o parser.c -H parser.h` is cleanest
* Graphviz: `parser.dot` when `-g` is used

---

# quick “which yacc is this” checks

```bash
readlink -f /usr/bin/yacc        # shows it points to /usr/bin/bison
yacc --version                    # runs bison in yacc mode
bison --print-datadir             # see where skeletons live
```

---

# build-system snippets

Meson

```meson
bison = find_program('bison')
gen = custom_target(
  'parser',
  input: 'parser.y',
  output: ['parser.c', 'parser.h'],
  command: [bison, '-d', '-o', '@OUTPUT0@', '@INPUT@'],
  depend_files: 'parser.y'
)

exe = executable('app', ['main.c', gen], install: true)
```

CMake

```cmake
find_program(BISON_EXECUTABLE bison)
add_custom_command(
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/parser.c ${CMAKE_CURRENT_BINARY_DIR}/parser.h
  COMMAND ${BISON_EXECUTABLE} -d -o ${CMAKE_CURRENT_BINARY_DIR}/parser.c ${CMAKE_SOURCE_DIR}/parser.y
  DEPENDS ${CMAKE_SOURCE_DIR}/parser.y
  COMMENT "Generating Bison parser"
)
add_executable(app main.c ${CMAKE_CURRENT_BINARY_DIR}/parser.c)
target_include_directories(app PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
```

---

# paste-friendly output banner for `bison` and `yacc`

```bash
#!/usr/bin/env bash
set -euo pipefail

banner() { printf '\n\033[1m=== %s ===\033[0m\n' "$*"; }
show() { banner "$*"; eval "$*" | sed 's/^/    /'; }

show 'bison --help'
show 'yacc --help'
show 'bison --print-datadir'
```
