#!/bin/bash

declare -A repo_checked_cache
declare -A skip_packages
declare -A maint_excluded_packages

PROGNAME="upGit"

TMP_DIR="/tmp/${PROGNAME}"

DEBUG_LOG="${TMP_DIR}/${PROGNAME}-debug.log"
ERROR_LOG="${TMP_DIR}/${PROGNAME}-error.log"
JSON_LOG="${TMP_DIR}/${PROGNAME}-json.log"
MAINT_BRANCH_LOG="${TMP_DIR}/${PROGNAME}-maint-branch.log"

FINAL_SCRIPT="${TMP_DIR}/upDay"
GIT_CLONES_DIR="${HOME}/.git_packages"
REPO_PATH="/var/db/repos/bp"
SHARE_DIR="/usr/share/ugscripts"
SKEL_FILE="${SHARE_DIR}/upDay.skel"
UPDATE_FILE="${TMP_DIR}/update_ebuild_commands.txt"

default_branch=""
repository_url=""
option=""

package_list=(
    "*lxqt*"
    "efibootmgr"
    "flex"
    "libldac"
    "musl"
    "obconf-qt"
    "openjade"
    "qterm*"
    "swig"
    "wpa_supplicant"
    "x265"
)

maint_excluded_list=(
    "efibootmgr"
    "musl"
)

for pkg in "${package_list[@]}"; do
    skip_packages["$pkg"]=1
done

for pkg in "${maint_excluded_list[@]}"; do
    maint_excluded_packages["$pkg"]=1
done

main() {
    mkdir -p "$TMP_DIR" "$SHARE_DIR" "$GIT_CLONES_DIR"
    : > "$UPDATE_FILE"
    : > "$ERROR_LOG"
    : > "$JSON_LOG"
    : > "$DEBUG_LOG"
    : > "$FINAL_SCRIPT"
    : > "$MAINT_BRANCH_LOG"

    cp $SKEL_FILE $FINAL_SCRIPT

    if [ -n "$option" ]; then
        echo "Option $option selected, executing upDay with this option..."
        chmod +x "$FINAL_SCRIPT"
        "$FINAL_SCRIPT" "$option"
    else
        echo "No option selected, updating all packages or the specified ones..."
        update_packages
    fi

    log_maint_branch_packages
}

update_packages() {
    if [[ ${#specific_packages[@]} -eq 0 ]]; then
        find "$REPO_PATH" -type f -regextype posix-extended -regex ".*-[0-9]{8}\.ebuild$" \
            -exec grep -l 'SNAPSHOT' {} + | xargs -r grep -L 'EGIT_REPO_URI' | while read -r ebuild_file; do
            process_repository_file "$ebuild_file"
        done
    else
        for pkg in "${specific_packages[@]}"; do
            find "$REPO_PATH" -type f -regextype posix-extended -regex "$pkg-[0-9]{8}\.ebuild$" \
                -exec grep -l 'SNAPSHOT' {} + | xargs -r grep -L 'EGIT_REPO_URI' | while read -r ebuild_file; do
                process_repository_file "$ebuild_file"
            done
        done
    fi

    sort "$ERROR_LOG" | uniq > "${ERROR_LOG}.tmp" && mv "${ERROR_LOG}.tmp" "$ERROR_LOG"
    sort "$UPDATE_FILE" | uniq > "${UPDATE_FILE}.tmp" && mv "${UPDATE_FILE}.tmp" "$UPDATE_FILE"

    replace_placeholder
    chmod +x "$FINAL_SCRIPT"
    "$FINAL_SCRIPT"
}

log_maint_branch_packages() {
    echo "Packages using the maint branch:" >> "$MAINT_BRANCH_LOG"
    sort "$MAINT_BRANCH_LOG" | uniq >> "${MAINT_BRANCH_LOG}.tmp" && mv "${MAINT_BRANCH_LOG}.tmp" "$MAINT_BRANCH_LOG"
    cat "$MAINT_BRANCH_LOG"
}

show_help() {
    echo "Usage: $0 [options] [package1 package2 ... packageN]"
    echo ""
    echo "Options:"
    echo "  --update-toolchain   Update the toolchain ebuilds (GCC, Binutils, Glibc, etc.)"
    echo "  --update-unsafe      Update packages marked as unsafe"
    echo "  --update-branches    Update packages based on specific branches"
    echo "  --help               Display this help and exit"
    echo ""
    echo "Without any options, the script updates all packages."
}

while (( "$#" )); do
    case "$1" in
        --update-toolchain | --update-unsafe | --update-branches)
            if [ -n "$option" ]; then
                echo "Error: Multiple options are not allowed."
                exit 1
            fi
            option="$1"
            shift
            ;;
        --help)
            show_help
            exit 0
            ;;
        -*|--*)
            echo "Error: Unsupported flag $1" >&2
            show_help
            exit 1
            ;;
        *)
            specific_packages+=("$1")
            shift
            ;;
    esac
done

replace_placeholder() {
    local output_file="$FINAL_SCRIPT"
    local temp_file="${output_file}.tmp"

    if [ ! -s "$UPDATE_FILE" ]; then
        echo "No updates to apply."
        exit 1
    fi

    local replacement_text=$(cat "$UPDATE_FILE")

    local replacement_text_escaped=$(printf '%s\n' "$replacement_text" | sed 's:[\/&]:\\&:g;$!s/$/\\/')

    sed "s|REPLACE_ME|${replacement_text_escaped}|g" "$output_file" > "$temp_file" && mv "$temp_file" "$output_file"

    return 0
}

get_branch() {
    local repo_url="$1"
    local package_path="$2"
    local package_name=$(basename "$package_path")
    local clone_dir="${GIT_CLONES_DIR}/$(basename "$package_path")"

    if [[ "${maint_excluded_packages[$package_name]}" ]]; then
        echo "Skipping maint branch for package: $package_name" >> "$DEBUG_LOG"
        return
    fi

    if [[ "$repo_url" =~ github\.com ]]; then
        handle_github "$repo_url"
    elif [[ "$repo_url" =~ gitlab\.com ]]; then
        handle_gitlab "$repo_url"
    fi

    echo "pre default_branch $default_branch" >> "$DEBUG_LOG"

    if [[ -z "$default_branch" ]]; then
        handle_fallback "$repo_url" "$clone_dir"
    fi

    if [[ "$default_branch" == "maint" ]]; then
        echo "$package_path" >> "$MAINT_BRANCH_LOG"
    fi

    return 0
}

handle_github() {
    local repo_url="$1"
    local repo_slug=$(echo "$repo_url" | sed -E 's|https?://github\.com/([^/]+/[^/]+).*|\1|')
    local encoded_slug=$(echo "$repo_slug" | sed 's/\//%2F/g')

    echo "repo_slug $repo_slug" >> "$DEBUG_LOG"
    echo "urlencode $encoded_slug" >> "$DEBUG_LOG"

    local api_url="https://api.github.com/repos/$repo_slug"
    echo "api_url $api_url" >> "$DEBUG_LOG"
    local auth_header="Authorization: token $GITHUB_TOKEN"
    echo "auth_header $auth_header" >> "$DEBUG_LOG"

    local default_branch_info=$(curl -s -H "$auth_header" "$api_url")
    if [[ $? -ne 0 || -z "$default_branch_info" ]] || [[ "$default_branch_info" == *"Could not resolve host"* ]]; then
        echo "Failed to fetch branch info" >> "$ERROR_LOG"
        echo "$default_branch_info" >> "$JSON_LOG"
        return 1
    else
        echo "Successfully fetched branch info: $default_branch_info" >> "$JSON_LOG"
        default_branch=$(echo "$default_branch_info" | jq -r '.default_branch')
        echo "github default_branch $default_branch" >> "$DEBUG_LOG"

        local maint_branch_info=$(curl -s -H "$auth_header" "$api_url/branches/maint")
        if [[ $? -eq 0 && -n "$maint_branch_info" && "$maint_branch_info" != *"Branch not found"* ]]; then
            echo "maint_branch exists" >> "$DEBUG_LOG"
            echo "Maint branch info: $maint_branch_info" >> "$JSON_LOG"
            default_branch=maint
        else
            echo "maint_branch does not exist" >> "$ERROR_LOG"
        fi

        return 0
    fi
}

handle_gitlab() {
    local repo_url="$1"
    local repo_slug=$(echo "$repo_url" | sed -E 's|https?://gitlab\.com/([^/]+/[^/]+).*|\1|')
    local encoded_slug=$(echo "$repo_slug" | sed 's/\//%2F/g')

    echo "repo_slug $repo_slug" >> "$DEBUG_LOG"
    echo "urlencode $encoded_slug" >> "$DEBUG_LOG"

    local api_url="https://gitlab.com/api/v4/projects/$encoded_slug"
    echo "api_url $api_url" >> "$DEBUG_LOG"
    local auth_header="Authorization: Bearer $GITLAB_TOKEN"
    echo "auth_header $auth_header" >> "$DEBUG_LOG"

    local default_branch_info=$(curl -s -H "$auth_header" "$api_url")
    if [[ $? -ne 0 || -z "$default_branch_info" ]] || [[ "$default_branch_info" == *"Could not resolve host"* ]]; then
        echo "Failed to fetch branch info" >> "$ERROR_LOG"
        echo "$default_branch_info" >> "$JSON_LOG"
        return 1
    else
        echo "Successfully fetched branch info: $default_branch_info" >> "$JSON_LOG"
        default_branch=$(echo "$default_branch_info" | jq -r '.default_branch')
        echo "gitlab default_branch $default_branch" >> "$DEBUG_LOG"

        local maint_branch_info=$(curl -s -H "$auth_header" "$api_url/repository/branches/maint")
        if [[ $? -eq 0 && -n "$maint_branch_info" && "$maint_branch_info" != *"404 Branch Not Found"* ]]; then
            echo "maint_branch exists" >> "$DEBUG_LOG"
            echo "Maint branch info: $maint_branch_info" >> "$JSON_LOG"
            default_branch=maint
        else
            echo "maint_branch does not exist" >> "$ERROR_LOG"
        fi

        return 0
    fi
}

handle_fallback() {
    echo "running fallback" >> "$DEBUG_LOG"
    local repo_url="$1"
    local clone_dir="$2"
    local datetime=$(date "+%Y-%m-%d %H:%M:%S")

    if [[ -z "$repo_url" || -z "$clone_dir" ]]; then
        echo "[$datetime] Error: Missing required parameters." >> "$ERROR_LOG"
        return 1
    fi

    if [ ! -d "$clone_dir" ]; then
        echo "[$datetime] Attempting to clone $repo_url into $clone_dir" >> "$DEBUG_LOG"
        if ! git clone --depth 1 "$repo_url" "$clone_dir" 2>>"$ERROR_LOG"; then
            echo "[$datetime] Failed to clone $repo_url" >> "$ERROR_LOG"
            return 1
        fi
    fi

    pushd "$clone_dir" > /dev/null

    echo "[$datetime] Checking for 'maint' branch at remote" >> "$DEBUG_LOG"
    if git ls-remote --heads "$repo_url" maint | grep -q 'refs/heads/maint'; then
        default_branch="maint"
        echo "[$datetime] 'maint' branch is set as the default" >> "$DEBUG_LOG"
    else
        default_branch=$(git rev-parse --abbrev-ref HEAD)
        echo "[$datetime] Using default branch: $default_branch" >> "$DEBUG_LOG"
    fi

    popd > /dev/null

    if [[ "$default_branch" == "maint" ]]; then
        echo "$clone_dir" >> "$MAINT_BRANCH_LOG"
    fi

    return 0
}

append_update_command() {
    local package_path="$1"

    echo "update_ebuild \"\${REPO_PATH}/${package_path}\" \"${repository_url}\" \"${default_branch}\" \"0\" \"yes\"" >> "$UPDATE_FILE"
}

process_repository_file() {
    local ebuild_file="$1"
    local package_path=$(dirname "$ebuild_file")
    local package_name=$(basename "$package_path")

    echo "*****************************************************************" >> "$DEBUG_LOG"
    echo "package_path $package_path" >> "$DEBUG_LOG"
    echo "*****************************************************************" >> "$DEBUG_LOG"

    for skip_pattern in "${!skip_packages[@]}"; do
        if [[ "$package_name" == $skip_pattern ]]; then
            if [[ " ${specific_packages[*]} " =~ " $package_name " ]]; then
                echo "Skipping $package_name as it is in skip list."
            fi
            return 0
        fi
    done

    if (( ${#specific_packages[@]} != 0 )) && ! [[ " ${specific_packages[*]} " =~ " $package_name " ]]; then
        return 0
    fi

    echo "Processing $package_name..."

    grep -E 'SRC_URI="[^"]+"' "$ebuild_file" | while IFS= read -r line; do
        local raw_url=$(echo "$line" | grep -oE 'https?://[^"]+')
        process_url "$ebuild_file" "$raw_url" "$package_path"
    done
}

normalize_url() {
    local url="$1"
    url=${url//cgit/git}

    if [[ "$url" =~ gitweb\.cgi ]]; then
        url=$(echo "$url" | sed -E 's|.*/gitweb\.cgi\?p=([^&]+).*|git://git.gnupg.org/\1.git|')
    elif [[ "$url" =~ /-/ ]]; then
        url=$(echo "$url" | sed -E 's|/-/.*||')
    elif [[ "$url" =~ /archive/ ]]; then
        url=$(echo "$url" | sed -E 's|/archive/.*||')
    elif [[ "$url" =~ /snapshot/ ]]; then
        url=$(echo "$url" | sed -E 's|/snapshot/.*||')
    fi

    url=$(echo "$url" | sed -E 's|(\.git).*|\1|')

    echo "$url"
}

process_url() {
    local ebuild_file="$1"
    local url="$2"
    local package_path="$3"
    repository_url=$(normalize_url "$url")
    echo "repository_url $repository_url" >> "$DEBUG_LOG"

    if [[ -z "$repository_url" ]]; then
        echo "No valid repository URL extracted from $ebuild file" >> "$ERROR_LOG"
        return
    fi

    common_process "$ebuild_file" "$repository_url" "$package_path"
}

common_process() {
    local ebuild_file="$1"
    local repository_url="$2"
    local package_path="$3"
    local package_path_short=$(echo "$ebuild_file" | sed "s|^$REPO_PATH/||" | awk -F'/' 'NF>=3 {print $(NF-2) "/" $(NF-1)}')
    get_branch "$repository_url" "$package_path"

    echo "package_path_short $package_path_short" >> "$DEBUG_LOG"
    echo "repository_url $repository_url" >> "$DEBUG_LOG"
    echo "default_branch $default_branch" >> "$DEBUG_LOG"

    if [[ -z "$default_branch" ]]; then
        echo "$ebuild_file - Failed to access or get branch for $repository_url" >> "$ERROR_LOG"
    else
        append_update_command "$package_path_short" "$repository_url" "$default_branch"
    fi
}

main
